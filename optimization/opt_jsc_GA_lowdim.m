function [F_comm_opt, F_sensing_opt, GA_info] = opt_jsc_GA_lowdim( ...
    H_comm, sigmasq_ue, sensing_beam, sigmasq_radar_rcs, ...
    P_total, SINR_min_req, ...
    F_comm_ref, F_sensing_ref, ...
    rho, GA)

% =========================================
% Low-dimensional GA (2 variables: alpha, beta)
% =========================================

chrom_length = 2;   % [alpha, beta]

lb = [0.5, 0.5];
ub = [1.5, 1.5];

options = optimoptions('ga', ...
    'PopulationSize', GA.pop_size, ...
    'MaxGenerations', GA.max_gen, ...
    'CrossoverFraction', GA.crossover_rate, ...
    'MutationFcn', {@mutationgaussian, GA.mutation_rate}, ...
    'Display', 'off');

fitness_fn = @(x) ga_fitness_jsc_lowdim( ...
    x, H_comm, sigmasq_ue, sensing_beam, ...
    sigmasq_radar_rcs, ...
    P_total, SINR_min_req, ...
    F_comm_ref, F_sensing_ref, rho);

[x_best, fval, exitflag, output] = ga( ...
    fitness_fn, chrom_length, [], [], [], [], lb, ub, [], options);

[F_comm_opt, F_sensing_opt] = decode_lowdim( ...
    x_best, F_comm_ref, F_sensing_ref, P_total, rho);

GA_info.alpha = x_best(1);
GA_info.beta  = x_best(2);
GA_info.best_SSNR = -fval;
GA_info.generations = output.generations;
GA_info.exitflag = exitflag;

end
